<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Moto Wetter â€“ Snapshot Log (GPX + PWA)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- Icons & PWA -->
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#111827">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Moto Wetter">
  <style>
    :root {
      --bg: #f9fafb; --text: #111827; --muted: #6b7280;
      --chip-bg: #111827; --chip-br: rgba(255,255,255,.9); --chip-shadow: 0 1px 0 rgba(0,0,0,.25);
      --route: #6b705c; --route-outline: #ffffff; --fallback: #9ca3af;
      --me: #2563eb; --btn-bg: rgba(17,24,39,.96); --btn-br: rgba(255,255,255,.9); --btn-tx: #fff;
      --accent: #111827;
      --snap: #0ea5e9;         /* local snapshots */
      --snap-outline: #ffffff;
      --hist: #8b5cf6;         /* published history */
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); }
    #map { width: 100%; height: 100vh; }

    .toolbar { position: absolute; top: 12px; left: 12px; display: grid; gap: 8px; z-index: 1000; }
    .btn {
      appearance: none; border: 2px solid var(--btn-br); background: var(--btn-bg); color: var(--btn-tx);
      border-radius: 999px; padding: 6px 10px; font: 700 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,.18); min-width: 40px; -webkit-tap-highlight-color: transparent; touch-action: manipulation;
    }
    .segbtns { display:flex; gap:6px; flex-wrap: wrap; }
    .btn.pill { border-radius: 999px; padding: 5px 9px; }
    .btn.active { box-shadow: 0 6px 14px rgba(0,0,0,.22); border-color: rgba(255,255,255,1); }

    .status { position: absolute; bottom: 12px; left: 12px; z-index: 1000;
      background: rgba(255,255,255,.96); border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: var(--muted); box-shadow: 0 1px 2px rgba(0,0,0,.06); }

    .chip-marker { transform: translate(-50%, -34px); }
    .chip-marker > div {
      display: inline-block; padding: 4px 10px; border-radius: 999px;
      background: var(--chip-bg); color: #fff; font: 700 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      border: 2px solid var(--chip-br); box-shadow: 0 6px 16px rgba(0,0,0,.18);
      white-space: nowrap; max-width: 220px; overflow: hidden; text-overflow: ellipsis; letter-spacing: .2px; text-shadow: var(--chip-shadow);
    }

    .fab {
      position: fixed;
      right: calc(env(safe-area-inset-right, 0px) + 14px);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 16px);
      z-index: 3000;
      width: 64px; height: 64px; border-radius: 50%;
      display: grid; place-items: center;
      background: var(--accent); color: #fff; font: 900 14px/1 system-ui, -apple-system, Segoe UI;
      border: 2px solid rgba(255,255,255,.9); box-shadow: 0 12px 24px rgba(0,0,0,.22);
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    @supports (bottom: constant(safe-area-inset-bottom)) {
      .fab { right: calc(constant(safe-area-inset-right) + 14px); bottom: calc(constant(safe-area-inset-bottom) + 16px); }
    }

    .leaflet-control { border-radius: 8px; overflow: hidden; }

    @media (max-width: 480px) {
      .toolbar { gap: 6px; }
      .btn { font-size: 11px; padding: 5px 9px; }
      .btn.pill { padding: 4px 8px; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="toolbar">
    <button class="btn" id="fit">Zentrieren</button>
    <button class="btn" id="locate">Ortung</button>
    <button class="btn" id="share">Teilen</button>
    <div class="segbtns">
      <button class="btn pill" id="modeToday">Heute</button>
      <button class="btn pill" id="modeTomorrow">Morgen</button>
      <button class="btn pill" id="modeDayAfter">Ãœbermorgen</button>
      <button class="btn pill" id="autoLog">Autoâ€‘Log</button>
      <button class="btn pill" id="snapExport">Export</button>
    </div>
  </div>

  <button class="fab" id="fabNow" title="Jetzt-Wetter" aria-label="Jetzt-Wetter">JETZT</button>
  <div class="status" id="status">Karte lÃ¤dt â€¦</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    // --- PWA SW ---
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async function() {
        try { const reg = await navigator.serviceWorker.register('./sw.js'); setTimeout(()=>reg.update().catch(()=>{}), 2000); }
        catch(e){ console.warn('SW reg fail', e); }
      });
    }

    function setStatus(msg, cls){
      var s = document.getElementById('status'); s.textContent = msg; s.className = 'status '+(cls||''); s.style.display='block';
      clearTimeout(s._t); s._t = setTimeout(function(){ s.style.display='none'; }, 1800);
    }
    function cssVar(name, fallback){ 
      var v = getComputedStyle(document.documentElement).getPropertyValue(name);
      v = v ? v.trim() : '';
      return v || fallback;
    }

    // --- Points of route ---
    const points = [
      { name: "GrosshÃ¶chstetten (CH)", lat: 46.906, lon: 7.638 },
      { name: "Interlaken (CH)",       lat: 46.686, lon: 7.863 },
      { name: "Andermatt (CH)",        lat: 46.637, lon: 8.593 },
      { name: "Bonaduz (CH)",          lat: 46.81175849, lon: 9.400583312 },
      { name: "St. Moritz (CH)",       lat: 46.490, lon: 9.835 },
      { name: "Bormio (IT)",           lat: 46.468, lon: 10.366 },
      { name: "Bozen (IT)",            lat: 46.498, lon: 11.354 },
      { name: "Pieve di Cadore (IT)",  lat: 46.427, lon: 12.368 },
      { name: "Tolmezzo (IT)",         lat: 46.402, lon: 13.020 },
      { name: "Bovec (SI)",            lat: 46.338, lon: 13.552 },
      { name: "Tolmin (SI)",           lat: 46.185, lon: 13.733 },
      { name: "AjdovÅ¡Äina (SI)",       lat: 45.886, lon: 13.909 },
      { name: "Nova Vas (SI)",         lat: 45.755, lon: 14.514 },
      { name: "KoÄevje (SI)",          lat: 45.643, lon: 14.863 },
      { name: "Sopac (HR)",            lat: 45.132, lon: 14.941 },
      { name: "Breze (HR)",            lat: 44.997, lon: 14.987 },
      { name: "Senj (HR)",             lat: 44.989, lon: 14.905 }
    ];
    function stripCountry(s){ return s.replace(/\s*\([A-Z]{2}\)\s*$/, ''); }

    // --- Map ---
    const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '&copy; OSM & CARTO' });
    const map = L.map('map', { layers: [cartoLight] });
    window.addEventListener('load', function(){ setTimeout(function(){ map.invalidateSize(); }, 150); });

    document.getElementById('fit').addEventListener('click', function(){ fitRoute(); });
    document.getElementById('locate').addEventListener('click', function(){ locateMe(true); });
    document.getElementById('fabNow').addEventListener('click', function(){ locateMe(true, true); });
    document.getElementById('share').addEventListener('click', async function(){
      const url = location.href;
      if (navigator.share) { try { await navigator.share({ title: document.title, url: url }); } catch(e){} }
      else { try { await navigator.clipboard.writeText(url); alert('Link kopiert.'); } catch(e){ alert(url); } }
    });

    // --- Mode (persist) ---
    var modeBtns = { today: document.getElementById('modeToday'), tomorrow: document.getElementById('modeTomorrow'), dayAfter: document.getElementById('modeDayAfter') };
    var mode = 'today';
    function applyModeUI() { for (var k in modeBtns) modeBtns[k].classList.toggle('active', (k===mode)); }
    function setMode(m, persist){ mode=m; applyModeUI(); if (persist) { try { localStorage.setItem('mw-mode', m); } catch(e){} } }
    function smartDefaultMode(){ try { var saved = localStorage.getItem('mw-mode'); if (saved) return saved; } catch(e){}; return (new Date().getHours() >= 16) ? 'tomorrow' : 'today'; }
    setMode(smartDefaultMode(), false);
    modeBtns.today.addEventListener('click', function(){ setMode('today', true); });
    modeBtns.tomorrow.addEventListener('click', function(){ setMode('tomorrow', true); });
    modeBtns.dayAfter.addEventListener('click', function(){ setMode('dayAfter', true); });

    // --- Markers ---
    var markers = [];
    points.forEach(function(p){
      var m = L.marker([p.lat, p.lon], { icon: L.divIcon({ className:'chip-marker', html:'<div>'+stripCountry(p.name)+'</div>', iconSize:[10,10], iconAnchor:[10,24], popupAnchor:[0,-20] })}).addTo(map);
      m.on('click', function(){ m.bindPopup('<div>Lade Wetterâ€¦</div>').openPopup(); loadPopupForPoint(p, m); });
      markers.push({ marker: m, data: p });
    });

    // --- Fallback polyline (before GPX/OSRM) ---
    var latlngs = points.map(function(p){ return [p.lat, p.lon]; });
    var fallbackGroup = L.layerGroup().addTo(map);
    L.polyline(latlngs, { color: '#ffffff', weight: 8, opacity: .95, dashArray: '8 10' }).addTo(fallbackGroup);
    L.polyline(latlngs, { color: '#6b7280', weight: 4, opacity: .95, dashArray: '8 10' }).addTo(fallbackGroup);
    map.fitBounds(L.latLngBounds(latlngs), { padding: [24,24] });

    // --- Route layers ---
    var routeGroup = L.layerGroup().addTo(map);
    var routeBounds = null;
    var routeCoords = null;
    function drawCased(coords, color, outline){
      L.polyline(coords, { color: outline || cssVar('--route-outline','#ffffff'), weight: 9, opacity: 0.95 }).addTo(routeGroup);
      L.polyline(coords, { color: color, weight: 6, opacity: 1.0 }).addTo(routeGroup);
    }

    // --- GPX support (filenames from previous step) ---
    const GPX_FILES = [
      'gpx/stegra_route_tag_1.gpx',
      'gpx/stegra_route_tag_2.gpx',
      'gpx/stegra_route_tag_3.gpx',
      'gpx/stegra_route_tag_4.gpx',
      'gpx/stegra_route_tag_5_1.gpx',
      'gpx/stegra_route_tag_5_2.gpx'
    ];

    function parseGPX(xmlText){
      const doc = new DOMParser().parseFromString(xmlText, 'text/xml');
      let pts = Array.from(doc.getElementsByTagName('trkpt'));
      if (pts.length === 0) pts = Array.from(doc.getElementsByTagName('rtept'));
      const coords = [];
      for (const el of pts){
        const lat = parseFloat(el.getAttribute('lat'));
        const lon = parseFloat(el.getAttribute('lon'));
        if (!isNaN(lat) && !isNaN(lon)) coords.push([lat, lon]);
      }
      return coords;
    }

    function downsample(coords, maxPoints){
      if (!coords || coords.length <= maxPoints) return coords;
      const step = Math.ceil(coords.length / maxPoints);
      const out = [];
      for (let i=0;i<coords.length;i+=step) out.push(coords[i]);
      if (coords.length % step !== 0) out.push(coords[coords.length-1]);
      return out;
    }

    async function loadGPX(){
      if (!GPX_FILES || GPX_FILES.length === 0) return false;
      setStatus('Lade GPX-Tracks â€¦');
      let merged = [];
      for (const file of GPX_FILES){
        try {
          const res = await fetch(file, { cache: 'no-cache' });
          if (!res.ok) throw new Error(file+' '+res.status);
          const text = await res.text();
          const coords = parseGPX(text);
          if (coords.length) { merged = merged.concat(coords); } else { console.warn('Keine Punkte in', file); }
        } catch (e){ console.warn('GPX Ladefehler', file, e); }
      }
      if (merged.length < 2) { setStatus('GPX nicht gefunden â€“ zeige Fallback/OSRM.'); return false; }
      merged = downsample(merged, 8000);
      routeGroup.clearLayers();
      drawCased(merged, cssVar('--route','#6b705c'));
      routeCoords = merged;
      routeBounds = L.latLngBounds(merged);
      map.removeLayer(fallbackGroup);
      map.fitBounds(routeBounds, { padding: [24,24] });
      setStatus('GPX-Route geladen ('+merged.length+' Punkte).');
      return true;
    }

    // --- OSRM fallback ---
    function decodePolyline6(str){
      var index = 0, lat = 0, lon = 0, coords = [];
      var factor = 1e-6;
      while (index < str.length) {
        var b, res = 0, sh = 0;
        do { b = str.charCodeAt(index++) - 63; res |= (b & 0x1f) << sh; sh += 5; } while (b >= 0x20);
        var dlat = (res & 1) ? ~(res >> 1) : (res >> 1); lat += dlat;
        res = 0; sh = 0;
        do { b = str.charCodeAt(index++) - 63; res |= (b & 0x1f) << sh; sh += 5; } while (b >= 0x20);
        var dlon = (res & 1) ? ~(res >> 1) : (res >> 1); lon += dlon;
        coords.push([lat * factor, lon * factor]);
      }
      return coords;
    }
    function osrmUrlAll(points) {
      var coords = points.map(function(p){ return p.lon+','+p.lat; }).join(';');
      return 'https://router.project-osrm.org/route/v1/driving/'+coords+'?overview=full&geometries=polyline6&alternatives=false&steps=false&continue_straight=true';
    }
    async function fetchWithTimeout(url, ms){
      const ctrl = new AbortController(); const id = setTimeout(function(){ ctrl.abort(); }, ms);
      try { const res = await fetch(url, { signal: ctrl.signal }); return res; } finally { clearTimeout(id); }
    }

    (async function initRoute(){
      const ok = await loadGPX();
      if (ok) return;
      try {
        const res = await fetchWithTimeout(osrmUrlAll(points), 8000);
        if (!res.ok) throw new Error('OSRM '+res.status);
        const data = await res.json();
        if (!data.routes || !data.routes[0]) throw new Error('Keine Route');
        const coords = decodePolyline6(data.routes[0].geometry).map(function(x){ return [x[0], x[1]]; });
        drawCased(coords, cssVar('--route','#6b705c'));
        routeCoords = coords;
        routeBounds = L.latLngBounds(coords);
        map.removeLayer(fallbackGroup);
        setStatus('OSRM-Route geladen.');
      } catch(e){
        console.warn('OSRM Problem', e);
        setStatus('Zeige Fallback (StraÃŸenroute nicht geladen).');
      }
    })();

    // --- Weather / Popups ---
    function windyLink(lat, lon){ var z=8; return 'https://www.windy.com/'+lat.toFixed(3)+'/'+lon.toFixed(3)+'?'+lat.toFixed(3)+','+lon.toFixed(3)+','+z; }
    var codeMap = {0:"Klar â˜€ï¸",1:"Ãœberwiegend klar ğŸŒ¤ï¸",2:"Wechselhaft â›…",3:"Bedeckt â˜ï¸",45:"Nebel ğŸŒ«ï¸",48:"Reif/Nebel ğŸŒ«ï¸",51:"Nieselregen ğŸŒ¦ï¸",53:"Nieselregen ğŸŒ¦ï¸",55:"Nieselregen ğŸŒ¦ï¸",56:"Gefrierender Niesel ğŸŒ§ï¸â„ï¸",57:"Gefrierender Niesel ğŸŒ§ï¸â„ï¸",61:"Regen ğŸŒ§ï¸",63:"Regen ğŸŒ§ï¸",65:"Starker Regen ğŸŒ§ï¸",66:"Gefrierender Regen ğŸŒ§ï¸â„ï¸",67:"Gefrierender Regen ğŸŒ§ï¸â„ï¸",71:"Schnee ğŸŒ¨ï¸",73:"Schnee ğŸŒ¨ï¸",75:"Starker Schnee ğŸŒ¨ï¸",77:"Schneegriesel ğŸŒ¨ï¸",80:"Schauer ğŸŒ¦ï¸",81:"Schauer ğŸŒ¦ï¸",82:"Starke Schauer ğŸŒ§ï¸",85:"Schneeschauer ğŸŒ¨ï¸",86:"Starke Schneeschauer ğŸŒ¨ï¸",95:"Gewitter â›ˆï¸",96:"Gewitter mit Hagel â›ˆï¸",97:"Gewitter mit Hagel â›ˆï¸"};
    function fmt(n, unit){ return (n==null || isNaN(n)) ? '-' : (Math.round(n)+(unit||'')); }

    async function loadPopupForPoint(p, marker) { await loadPopupGeneric(p.name, p.lat, p.lon, marker); }
    async function loadPopupGeneric(label, lat, lon, marker) {
      var url = 'https://api.open-meteo.com/v1/forecast?latitude='+lat+'&longitude='+lon
              + '&current=temperature_2m,precipitation,wind_speed_10m,weather_code'
              + '&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,weather_code'
              + '&timezone=auto';
      try {
        const res = await fetch(url); const data = await res.json();
        var cur = data.current || {}; var d = data.daily || {};
        var idx = (mode==='today') ? 0 : (mode==='tomorrow' ? 1 : 2);
        var dayLabel = (idx===0?'Heute':(idx===1?'Morgen':'Ãœbermorgen'));
        var wxCodeDay = (d.weather_code && d.weather_code[idx] != null) ? d.weather_code[idx] : null;
        var wxDescDay = codeMap[wxCodeDay] || 'â€“';
        var maxT = d.temperature_2m_max && d.temperature_2m_max[idx];
        var minT = d.temperature_2m_min && d.temperature_2m_min[idx];
        var pop  = d.precipitation_probability_max && d.precipitation_probability_max[idx];
        var html = '<div>' +
          '<strong>'+label+'</strong><br/>' +
          '<div style="margin:4px 0 6px;"><em>'+dayLabel+'</em>: <strong>Max '+fmt(maxT,'Â°C')+'</strong> Â· Min '+fmt(minT,'Â°C')+' Â· Regenwkt. '+(pop==null?'-':pop+'%')+' Â· '+wxDescDay+'</div>' +
          '<div style="font-size:12px;color:var(--muted);">Jetzt: '+fmt(cur.temperature_2m,'Â°C')+' Â· Wind '+fmt(cur.wind_speed_10m,' km/h')+' Â· '+(codeMap[cur.weather_code] || 'â€“')+'</div>' +
          '<a href="'+windyLink(lat, lon)+'" target="_blank" rel="noopener">Details auf Windy Ã¶ffnen</a>' +
        '</div>';
        marker.bindPopup(html).openPopup();
      } catch(e) {
        marker.bindPopup('<div><strong>'+label+'</strong><br/><span style="color:var(--muted);">Wetter gerade nicht erreichbar.</span></div>').openPopup();
      }
    }

    // --- Snapshot log (local only) ---
    const SNAP_KEY = 'mw-snaps-v1';
    let snapData = [];
    let snapsLayer = L.layerGroup().addTo(map);
    let autoLogEnabled = true; // default ON
    const MIN_INTERVAL_HOURS = 3; // don't auto-log more than once per X hours
    function loadSnaps(){ try { snapData = JSON.parse(localStorage.getItem(SNAP_KEY) || '[]'); } catch(e){ snapData=[]; } }
    function saveSnaps(){ try { localStorage.setItem(SNAP_KEY, JSON.stringify(snapData)); } catch(e){} }
    function drawSnaps(){
      snapsLayer.clearLayers();
      snapData.forEach(s => {
        const m = L.circleMarker([s.lat, s.lon], { radius: 5, weight: 2, color: getComputedStyle(document.documentElement).getPropertyValue('--snap').trim() || '#0ea5e9', fillOpacity:.7 });
        const when = new Date(s.t).toLocaleString();
        const desc = (s.wx_desc||''); const temp = (s.temp!=null? Math.round(s.temp)+'Â°C':'-'); const wind = (s.wind!=null? Math.round(s.wind)+' km/h':'-');
        m.bindPopup('<strong>Snapshot</strong><br>'+when+'<br>'+temp+' Â· Wind '+wind+' Â· '+desc);
        m.addTo(snapsLayer);
      });
      if (snapData.length>1){
        const coords = snapData.map(s => [s.lat, s.lon]);
        L.polyline(coords, { color: '#ffffff', weight: 7, opacity: .9 }).addTo(snapsLayer);
        L.polyline(coords, { color: getComputedStyle(document.documentElement).getPropertyValue('--snap').trim() || '#0ea5e9', weight: 4, opacity: 1 }).addTo(snapsLayer);
      }
    }
    function hoursBetween(a,b){ return Math.abs((b-a)/36e5); }
    function lastSnap(){ return snapData.length? snapData[snapData.length-1]: null; }

    async function snapshotNow(lat, lon){
      // fetch current weather for snapshot
      const url = 'https://api.open-meteo.com/v1/forecast?latitude='+lat+'&longitude='+lon+'&current=temperature_2m,precipitation,wind_speed_10m,weather_code&timezone=auto';
      try {
        const res = await fetch(url);
        const data = await res.json();
        const cur = data.current || {};
        const codeMapLocal = {0:"Klar â˜€ï¸",1:"Ãœberwiegend klar ğŸŒ¤ï¸",2:"Wechselhaft â›…",3:"Bedeckt â˜ï¸",45:"Nebel ğŸŒ«ï¸",48:"Reif/Nebel ğŸŒ«ï¸",51:"Nieselregen ğŸŒ¦ï¸",53:"Nieselregen ğŸŒ¦ï¸",55:"Nieselregen ğŸŒ¦ï¸",56:"Gefrierender Niesel ğŸŒ§ï¸â„ï¸",57:"Gefrierender Niesel ğŸŒ§ï¸â„ï¸",61:"Regen ğŸŒ§ï¸",63:"Regen ğŸŒ§ï¸",65:"Starker Regen ğŸŒ§ï¸",66:"Gefrierender Regen ğŸŒ§ï¸â„ï¸",67:"Gefrierender Regen ğŸŒ§ï¸â„ï¸",71:"Schnee ğŸŒ¨ï¸",73:"Schnee ğŸŒ¨ï¸",75:"Starker Schnee ğŸŒ¨ï¸",77:"Schneegriesel ğŸŒ¨ï¸",80:"Schauer ğŸŒ¦ï¸",81:"Schauer ğŸŒ¦ï¸",82:"Starke Schauer ğŸŒ§ï¸",85:"Schneeschauer ğŸŒ¨ï¸",86:"Starke Schneeschauer ğŸŒ¨ï¸",95:"Gewitter â›ˆï¸",96:"Gewitter mit Hagel â›ˆï¸",97:"Gewitter mit Hagel â›ˆï¸"};
        const rec = {
          t: new Date().toISOString(),
          lat: lat, lon: lon,
          temp: cur.temperature_2m, wind: cur.wind_speed_10m, wx_code: cur.weather_code,
          wx_desc: codeMapLocal[cur.weather_code] || ''
        };
        snapData.push(rec); saveSnaps(); drawSnaps();
        setStatus('Snapshot gespeichert.');
      } catch(e){
        setStatus('Snapshot: Wetter nicht erreichbar');
      }
    }

    async function tryAutoSnapshot(){
      if (!autoLogEnabled) return;
      loadSnaps();
      const last = lastSnap();
      const now = new Date();
      if (last && hoursBetween(new Date(last.t), now) < MIN_INTERVAL_HOURS) {
        setStatus('Autoâ€‘Log Ã¼bersprungen (zu frisch)');
        return;
      }
      // use last known position (lastMe) or request once
      if (lastMe){ snapshotNow(lastMe.lat, lastMe.lon); }
      else {
        if (!navigator.geolocation) return;
        navigator.geolocation.getCurrentPosition(function(pos){
          snapshotNow(pos.coords.latitude, pos.coords.longitude);
        }, function(err){ console.warn('AutoSnapshot Geo-Error', err); }, { enableHighAccuracy: true, timeout: 6000, maximumAge: 60000 });
      }
    }

    // --- Export / Publish ---
    function exportSnaps(){
      loadSnaps();
      if (!snapData.length){ alert('Keine Snapshots vorhanden.'); return; }
      const fc = {
        type: 'FeatureCollection',
        generatedAt: new Date().toISOString(),
        features: [
          { type:'Feature', geometry:{ type:'LineString', coordinates: snapData.map(s => [s.lon, s.lat]) }, properties:{ kind:'snapline', points:snapData.length } },
          *snapData.map(s => ({ type:'Feature', geometry:{ type:'Point', coordinates:[s.lon, s.lat] }, properties:{ t:s.t, temp:s.temp, wind:s.wind, wx_code:s.wx_code, wx_desc:s.wx_desc } }))
        ]
      };
      const blob = new Blob([JSON.stringify(fc, null, 2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'history.json'; a.click(); URL.revokeObjectURL(a.href);
      setStatus('Export erstellt (history.json)');
    }

    async function loadPublishedHistory(){
      try {
        const res = await fetch('history/history.json', { cache: 'no-cache' });
        if (!res.ok) throw new Error(res.status);
        const data = await res.json();
        const features = data.features || [];
        const histLayer = L.layerGroup().addTo(map);
        // Draw line first (if exists)
        const line = features.find(f => f.geometry && f.geometry.type==='LineString');
        if (line){
          const coords = line.geometry.coordinates.map(c => [c[1], c[0]]);
          L.polyline(coords, { color: '#ffffff', weight: 8, opacity: .9 }).addTo(histLayer);
          L.polyline(coords, { color: getComputedStyle(document.documentElement).getPropertyValue('--hist').trim() || '#8b5cf6', weight: 5, opacity: 1 }).addTo(histLayer);
        }
        // Draw points
        features.filter(f => f.geometry && f.geometry.type==='Point').forEach(f => {
          const c = f.geometry.coordinates; const p = f.properties || {};
          const when = p.t ? new Date(p.t).toLocaleString() : '';
          const temp = (p.temp!=null? Math.round(p.temp)+'Â°C':'-'); const wind = (p.wind!=null? Math.round(p.wind)+' km/h':'-');
          const desc = p.wx_desc || '';
          L.circleMarker([c[1], c[0]], { radius: 5, weight: 2, color: getComputedStyle(document.documentElement).getPropertyValue('--hist').trim() || '#8b5cf6', fillOpacity:.7 })
            .bindPopup('<strong>Besuch</strong><br>'+when+'<br>'+temp+' Â· Wind '+wind+' Â· '+desc).addTo(histLayer);
        });
        setStatus('VerÃ¶ffentlichte Besuche geladen');
      } catch(e){
        console.log('Keine verÃ¶ffentlichte History gefunden.');
      }
    }

    // --- Geolocate (me) ---
    var meMarker = null;
    var lastMe = null;
    function markMe(lat, lon, recenter){
      lastMe = {lat, lon};
      if (meMarker) { map.removeLayer(meMarker); }
      meMarker = L.circleMarker([lat, lon], { radius: 6, weight: 2, color: cssVar('--me','#2563eb'), fillOpacity: .6 }).addTo(map);
      meMarker.bindPopup('Lade Wetterâ€¦').openPopup();
      meMarker.on('click', function(){
        meMarker.bindPopup('Lade Wetterâ€¦').openPopup();
        loadPopupGeneric('Dein Standort', lat, lon, meMarker);
      });
      loadPopupGeneric('Dein Standort', lat, lon, meMarker);
      if (recenter) {
        if (routeBounds){
          var inside = routeBounds.contains([lat, lon]);
          if (inside){ map.setView([lat, lon], 11); }
          else { var combo = routeBounds.pad(0); combo.extend([lat, lon]); map.fitBounds(combo, { padding: [28,28] }); }
        } else { map.setView([lat, lon], 11); }
      }
    }
    function locateMe(userAction, forceRecenter){
      var status = document.getElementById('status');
      status.style.display='block'; status.textContent = 'Bestimme deinen Standort â€¦';
      if (!navigator.geolocation) { status.textContent = 'Geolocation nicht verfÃ¼gbar.'; return; }
      navigator.geolocation.getCurrentPosition(function(pos){
        var latitude = pos.coords.latitude, longitude = pos.coords.longitude;
        markMe(latitude, longitude, true);
        status.textContent = 'Zentriert.'; setTimeout(function(){ status.style.display='none'; }, 1600);
        // After marking me, attempt auto snapshot (once per X hours)
        tryAutoSnapshot();
      }, function(err){
        console.warn('Geo-Error', err);
        status.textContent = 'Standort nicht erlaubt â€“ zeige Route.';
        fitRoute();
        setTimeout(function(){ status.style.display='none'; }, 1800);
      }, { enableHighAccuracy: true, timeout: 6000, maximumAge: 60000 });
    }

    // --- UI wiring for snaps ---
    document.getElementById('autoLog').addEventListener('click', function(){
      autoLogEnabled = !autoLogEnabled;
      this.classList.toggle('active', autoLogEnabled);
      this.textContent = autoLogEnabled ? 'Autoâ€‘Log' : 'Autoâ€‘Log aus';
      try { localStorage.setItem('mw-autolog', JSON.stringify(autoLogEnabled)); } catch(e){}
      setStatus(autoLogEnabled ? 'Autoâ€‘Log an' : 'Autoâ€‘Log aus');
    });
    document.getElementById('snapExport').addEventListener('click', function(){ exportSnaps(); });

    // Persist autoLog setting
    (function initAutoLog(){
      try {
        const saved = JSON.parse(localStorage.getItem('mw-autolog')||'true');
        autoLogEnabled = !!saved;
        const btn = document.getElementById('autoLog');
        if (autoLogEnabled) btn.classList.add('active');
        btn.textContent = autoLogEnabled ? 'Autoâ€‘Log' : 'Autoâ€‘Log aus';
      } catch(e){}
    })();

    // --- Auto-refresh weather ---
    setInterval(function(){
      if (document.visibilityState === 'visible' && lastMe && meMarker) {
        loadPopupGeneric('Dein Standort', lastMe.lat, lastMe.lon, meMarker);
        setStatus('Wetter aktualisiert');
      }
    }, 20 * 60 * 1000);

    function fitRoute(){
      var b = routeBounds || L.latLngBounds(latlngs);
      map.fitBounds(b, { padding: [24,24] });
      setStatus('Route zentriert.');
    }

    (function start(){
      loadSnaps(); drawSnaps();
      loadPublishedHistory();
      fitRoute();
      locateMe(false);
    })();
  </script>
</body>
</html>
